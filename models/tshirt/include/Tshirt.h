
#ifndef TSHIRT_H
#define TSHIRT_H

#include "kernels/schaake_partitioning.hpp"
#include "Nonlinear_Reservoir.hpp"
#include "GIUH.hpp"
#include "Pdm03.h"
#include <cmath>
#include <vector>

namespace tshirt {

    //! Tshirt parameters struct
    /*!
        This structure provides storage for the parameters of the Tshirt hydrological model
    */

    struct tshirt_params
    {
        double maxsmc;              //!< saturated soil moisture content (sometimes theta_e or smcmax)
        double wltsmc;              //!< wilting point soil moisture content
        double satdk;               //!< vertical saturated hydraulic conductivity [m s^-1] (sometimes Kperc or Ks)
        double satpsi;              //!< saturated capillary head [m]
        // TODO: explain more what this is
        double slope;               //!< SLOPE parameter
        double b;                   //!< 'b' exponent on Clapp-Hornberger soil water relations (sometime bexp)
        double multiplier;          //!< the multiplier applied to 'satdk' to route water rapidly downslope in subsurface (sometimes 'mult' or 'LKSATFAC')
        double alpha_fc;            //!< alpha constant for given soil type for relative suction head value, with respect to Hatm
        double Klf;                 //!< lateral flow independent calibration parameter
        double Kn;                  //!< Nash cascade linear reservoir coefficient lateral flow parameter
        int nash_n;                 //!< number of nash cascades
        double Cgw;                 //!< Ground water flow param
        double expon;               //!< Ground water flow exponent param (analogous to NWM 2.0 expon param)
        double max_soil_storage_meters;  //!< Subsurface soil water flow max storage param ("Ssmax"), calculated from maxsmc and depth
        double max_groundwater_storage_meters;    //!< Ground water flow max storage param ("Sgwmax"; analogous to NWM 2.0 zmax param)
        const double depth = 2.0;         //!< Total soil column depth ('D') [m]

        //! Constructor for tshirt parameters
        /*!
            Constructor for tshirt param objects.
        */
        tshirt_params(double maxsmc, double wltsmc, double satdk, double satpsi, double slope, double b,
                double multiplier, double alpha_fc, double Klf, double Kn, int nash_n, double Cgw, double expon) :
                maxsmc(maxsmc),
                wltsmc(wltsmc),
                satdk(satdk),
                satpsi(satpsi),
                slope(slope),
                b(b),
                multiplier(multiplier),
                alpha_fc(alpha_fc),
                Klf(Klf),
                Kn(Kn),
                nash_n(nash_n),
                Cgw(Cgw),
                expon(expon)
        {
            this->max_soil_storage_meters = this->depth * this->maxsmc;
        }

    };

    /*!
     * Tshirt state structure
     *
     * This structure provides storage for the state used by Tshirt hydrological model at a particular time step.
     */
    struct tshirt_state
    {
        // TODO: confirm this is correct
        double soil_storage_meters;              //!< current water storage in soil column nonlinear reservoir ("Ss")
        double groundwater_storage_meters;       //!< current water storage in ground water nonlinear reservoir ("Sgw")
        double* nash_cascade_storeage_meters;    //!< water storage in nonlinear reservoirs of Nash Cascade for lateral subsurface flow

        // I think this doesn't belong in state, and so is just in run() below
        //double column_total_soil_moisture_deficit;    //!< soil column total moisture deficit

        tshirt_state(double ss, double sgw, double *nash_res_ptr = 0x0) : soil_storage_meters(ss),
                                                                          groundwater_storage_meters(sgw),
                                                                          nash_cascade_storeage_meters(nash_res_ptr) {}
    };

    /*!
     * Tshirt flux structure
     *
     * This structure provides storage for the fluxes generated by Tshirt at any time step
     */
    struct tshirt_fluxes
    {
        double surface_runoff;  //!< Direct surface runoff
        double Qgw;             //!< Groundwater flow from groundwater reservoir to channel flow
        double Qperc;           //!< Percolation flow from subsurface to groundwater reservoir
        double Qlf;             //!< Lateral subsurface flow
        double et_loss;         //!< Loss from ET

        tshirt_fluxes(double q_gw, double q_perc, double q_lf, double runoff, double et_loss) : Qgw(q_gw),
                                                                                                Qperc(q_perc),
                                                                                                Qlf(q_lf),
                                                                                                surface_runoff(runoff),
                                                                                                et_loss(et_loss) {

        }
    };

    // TODO: consider combining with or differentiating from similar hymod enum
    enum TshirtErrorCodes
    {
        TSHIRT_NO_ERROR = 0,
        TSHIRT_MASS_BALANCE_ERROR = 100
    };

    /*!
     * Tshirt kernel class
     *
     * This class implements the Tshirt hydrological model.
     */
    class tshirt_kernel
    {
    public:

        //! function to simulate losses due to evapotransportation
        static double calc_et(double soil_m, void* et_params)
        {
            pdm03_struct* pdm = (pdm03_struct*) et_params;
            pdm->XHuz = soil_m;
            pdm03_wrapper(pdm);

            return pdm->XHuz - soil_m;
        }

        //! Calculate the Cschaake, or the Schaake adjusted magic constant by soil type, based on the given Tshirt parameters
        static double calc_Cschaake(const tshirt_params& params)
        {
            return 3.0 * params.satdk / (2.0e-6);
        }

        /*!
         * Calculate the height above water table based on the given Tshirt parameters
         *
         * Calculate the height above water table based on known constants and the particular `alpha` value given for
         * relative soil suction head, as provided in the Tshirt parameters.
         *
         * @param params
         * @return
         */
        static double calc_Hwt(const tshirt_params& params)
        {
            // H_wt = alpha_fc * H_atm ; H_atm = P_atm / gamma ; P_atm = 101,300 [Pa] ; gamma = 9,810 [N m^-3] ('very nearly')
            return params.alpha_fc * (101300 / 9810);
        }

        static double calc_Sfc(const tshirt_params& params, const tshirt_state& state)
        {
            // TODO: account for possiblity of Hwt being less than 0.5 (though initially, it looks like this will never be the case)
            double z1 = calc_Hwt(params) - 0.5;
            double z2 = z1 + 2;

            // Note that z^( 1 - (1/b) ) / (1 - (1/b)) == b * (z^( (b - 1) / b ) / (b - 1)
            return params.maxsmc * pow((1.0 / params.satpsi), (-1.0 / params.b)) *
                   ((params.b * pow(z2, ((params.b - 1) / params.b)) / (params.b - 1)) -
                    (params.b * pow(z1, ((params.b - 1) / params.b)) / (params.b - 1)));
        }

        static void init_nash_cascade_vector(vector<Nonlinear_Reservoir>& reservoirs, const tshirt_params& params,
                const tshirt_state& state, const double activation, const double max_flow_velocity)
        {
            reservoirs.resize(params.nash_n);
            for ( unsigned long i = 0; i < reservoirs.size(); ++i )
            {
                //construct a single outlet nonlinear reservoir
                reservoirs[i] = Nonlinear_Reservoir(0, params.max_soil_storage_meters, state.nash_cascade_storeage_meters[i], params.Kn, 1, activation,
                                                    max_flow_velocity);
            }
        }

        //! run one time step of tshirt
        static int run(
                double dt,
                tshirt_params params,        //!< static parameters for tshirt
                tshirt_state state,          //!< model state
                tshirt_state& new_state,     //!< model state struct to hold new model state
                tshirt_fluxes& fluxes,       //!< model flux object to hold calculated fluxes
                double input_flux_meters,          //!< the amount water entering the system this time step
                // TODO: should/can this be a smart pointer?
                giuh_kernel* giuh_obj,       //!< kernel object for calculating GIUH runoff from subsurface lateral flow
                void* et_params)            //!< parameters for the et function
        {
            double column_total_soil_moisture_deficit = params.max_soil_storage_meters - state.soil_storage_meters;

            // Note this surface runoff value has not yet performed GIUH calculations
            double surface_runoff, subsurface_infiltration_flux;

            Schaake_partitioning_scheme(dt, calc_Cschaake(params), column_total_soil_moisture_deficit, input_flux_meters,
                    &surface_runoff, &subsurface_infiltration_flux);

            double Sfc = calc_Sfc(params, state);

            vector<Reservoir_Outlet> subsurface_outlets;

            // Keep track of the indexes of the specific outlets for later access
            int lf_outlet_index = 0;
            int perc_outlet_index = 1;

            // TODO: confirm these are correct
            // Max transmissivity
            double max_lateral_flow = params.satdk * params.multiplier * params.max_soil_storage_meters;
            double max_perc_flow = params.satdk;

            // init subsurface later flow outlet
            subsurface_outlets[lf_outlet_index] = Reservoir_Outlet(params.Klf, 1.0, Sfc, max_lateral_flow);
            // init subsurface percolation flow outlet
            subsurface_outlets[perc_outlet_index] = Reservoir_Outlet(params.satdk * params.slope, 1.0, Sfc, max_perc_flow);

            Nonlinear_Reservoir subsurface_reservoir(0.0, params.depth, state.soil_storage_meters, subsurface_outlets);

            double subsurface_excess;
            subsurface_reservoir.response_meters_per_second(subsurface_infiltration_flux, dt, subsurface_excess);

            // lateral subsurface flow
            double Qlf = subsurface_reservoir.velocity_meters_per_second_for_outlet(lf_outlet_index);

            // percolation flow
            double Qperc = subsurface_reservoir.velocity_meters_per_second_for_outlet(perc_outlet_index);

            // TODO: make sure ET doesn't need to be taken out sooner
            double new_soil_storage = subsurface_reservoir.get_storage_height_meters();
            fluxes.et_loss = calc_et(new_soil_storage, et_params);
            new_state.soil_storage_meters = new_soil_storage - fluxes.et_loss;

            // initialize the Nash cascade of nonlinear reservoirs
            std::vector<Nonlinear_Reservoir> nash_cascade;
            // TODO: verify correctness of activation_threshold (Sfc) and max_velocity (max_lateral_flow) arg values
            init_nash_cascade_vector(nash_cascade, params, state, Sfc, max_lateral_flow);

            // cycle through lateral flow Nash cascade of nonlinear reservoirs
            // loop essentially copied from Hymod logic, but with different variable names
            for(unsigned long int i = 0; i < nash_cascade.size(); ++i)
            {
                // get response water velocity of nonlinear reservoir
                Qlf = nash_cascade[i].response_meters_per_second(Qlf, dt, subsurface_excess);
                // TODO: confirm this is correct
                Qlf += subsurface_excess / dt;
            }

            // "raw" GW calculations
            //state.groundwater_storage_meters += Qperc * dt;
            //double Qgw = params.Cgw * ( exp(params.expon * state.groundwater_storage_meters / params.max_groundwater_storage_meters) - 1 );

            // Given the equation:
            //      double Qgw = params.Cgw * ( exp(params.expon * state.groundwater_storage_meters / params.max_groundwater_storage_meters) - 1 );
            // The max value should be when groundwater_storage_meters == max_groundwater_storage_meters, or ...
            double max_gw_velocity = params.Cgw * ( exp(params.expon) - 1 );
            // TODO: verify activation threshold
            Nonlinear_Reservoir groundwater_res(0, params.max_groundwater_storage_meters, state.groundwater_storage_meters, params.Cgw, 1, 0, max_gw_velocity);
            // TODO: what needs to be done with this value?
            double excess_gw_water;
            fluxes.Qgw = groundwater_res.response_meters_per_second(Qperc, dt, excess_gw_water);
            // update state
            new_state.groundwater_storage_meters = groundwater_res.get_storage_height_meters();

            // record other fluxes
            fluxes.Qlf = Qlf;
            fluxes.Qperc = Qperc;
            // Calculate GIUH surface runoff
            fluxes.surface_runoff = giuh_obj->calc_giuh_output(dt, surface_runoff);

            return 0;
        }

        static int mass_check(
                const tshirt_params &params,
                const tshirt_state &current_state,
                double input_flux_meters,
                const tshirt_state &next_state,
                const tshirt_fluxes &calculated_fluxes,
                double timestep_seconds)
        {
            // TODO: implement
            return 0;
        }
    };
}

//!

//!



#endif //TSHIRT_H
